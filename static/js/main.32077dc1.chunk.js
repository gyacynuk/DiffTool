(this["webpackJsonpdiff-tool"]=this["webpackJsonpdiff-tool"]||[]).push([[0],{44:function(e,t,n){e.exports=n.p+"static/media/edit_distance.6aca0a77.png"},45:function(e,t,n){e.exports=n.p+"static/media/matrix.6478087f.png"},52:function(e,t,n){e.exports=n(63)},57:function(e,t,n){},63:function(e,t,n){"use strict";n.r(t);var a=n(0),r=n.n(a),i=n(35),o=n.n(i),l=(n(57),n(14)),c=n(23),s=n(26),u=n(31),h=n(29),m=n(34),d=n(30),f=n(20),p=n(8),g=n(15);function E(){var e=Object(f.a)(["\n    color: #17A2B8;\n    text-decoration: none;\n"]);return E=function(){return e},e}function w(){var e=Object(f.a)(["\n    color: #FFF;\n    text-align: center;\n"]);return w=function(){return e},e}var b=Object(g.d)(p.f)(w()),y=Object(g.d)(p.f)(E()),v=function(e){function t(){return Object(c.a)(this,t),Object(u.a)(this,Object(h.a)(t).apply(this,arguments))}return Object(d.a)(t,e),Object(s.a)(t,[{key:"render",value:function(){return r.a.createElement(g.a,{backgroundColor:"#333",width:1,p:5},r.a.createElement(b,{variant:"h1"},"Text Comparison Tool"),r.a.createElement(b,{variant:"h4"},"Project by ",r.a.createElement(y,{forwardedAs:"a",href:"https://www.linkedin.com/in/griffin-yacynuk/",target:"_blank",rel:"noopener noreferrer"},"Griffin Yacynuk")),r.a.createElement(g.a,{row:!0,justifyContent:"center"},r.a.createElement(g.a,{col:"auto",forwardedAs:"a",href:"https://www.linkedin.com/in/griffin-yacynuk/",target:"_blank",rel:"noopener noreferrer",mx:2},r.a.createElement(b,{variant:"h4"},r.a.createElement("i",{className:"fab fa-linkedin"}))),r.a.createElement(g.a,{col:"auto",forwardedAs:"a",href:"https://github.com/gyacynuk",target:"_blank",rel:"noopener noreferrer",mx:2},r.a.createElement(b,{variant:"h4"},r.a.createElement("i",{className:"fab fa-github"})))))}}]),t}(a.Component);function j(){var e=Object(f.a)([" \n    font-family: 'Inconsolata', monospace;\n    white-space: nowrap;\n    overflow: auto;\n"]);return j=function(){return e},e}var D=Object(g.d)(p.g)(j()),k=function(e){function t(){return Object(c.a)(this,t),Object(u.a)(this,Object(h.a)(t).apply(this,arguments))}return Object(d.a)(t,e),Object(s.a)(t,[{key:"render",value:function(){var e=this;return r.a.createElement(r.a.Fragment,null,r.a.createElement(g.a,{row:!0},r.a.createElement(g.a,{col:{xs:1,md:.5},p:2},r.a.createElement(p.f,{variant:"h4"},"New Document"),r.a.createElement(D,{scale:"base",rows:10,defaultValue:this.props.newDocument,onChange:function(t){return e.props.updateDocument(t.target,!0)}})),r.a.createElement(g.a,{col:{xs:1,md:.5},p:2},r.a.createElement(p.f,{variant:"h4"},"Old Document"),r.a.createElement(D,{scale:"base",rows:10,defaultValue:this.props.oldDocument,onChange:function(t){return e.props.updateDocument(t.target,!1)}}))))}}]),t}(a.Component);function S(){var e=Object(f.a)(["\n    border: 1px solid rgba(0, 0, 0, 0.125);\n    border-radius: 4px;\n    overflow: scroll;\n"]);return S=function(){return e},e}var O=Object(g.d)(g.a)(S()),x=n(44),I=n.n(x),N=n(45),T=n.n(N);function C(){var e=Object(f.a)(["\n    font-family: 'Inconsolata', monospace;\n"]);return C=function(){return e},e}function A(){var e=Object(f.a)(["\n    max-width: 576px;\n    width: 100%;\n    height: auto;\n    object-fit: contain; \n    margin-bottom: -3px;\n"]);return A=function(){return e},e}var F=g.d.img(A()),L=Object(g.d)(p.f)(C()),R=function(e){function t(){return Object(c.a)(this,t),Object(u.a)(this,Object(h.a)(t).apply(this,arguments))}return Object(d.a)(t,e),Object(s.a)(t,[{key:"render",value:function(){return r.a.createElement(r.a.Fragment,null,r.a.createElement(p.f,{variant:"h2"},"Background"),r.a.createElement(p.d,null),r.a.createElement(p.f,{variant:"p"},"This project was inspired by the difficulties a friend of mine was experiencing at work, while trying to build a webpage which compared two JSON files. He wanted to highlight the differences between the two files and display this to the user, and he was able to find a component on NPM to do so. However, the component would naively compare each line from one file with the same line in the other. This was not ideal, since if one file had additions or deletions, they wouldn't be displayed properly. Since JSON files are highly structured, he was able to detect insertions or deletions by comparing the set of keys in each JSON object - then for each discrepancy he would insert a corresponding blank line in the other file. When applied recursively to all nested sub-objects, this approach fixed the issue, but it got me thinking that ",r.a.createElement("em",null,"there must be a better way to do this."),r.a.createElement("br",null),r.a.createElement("br",null),"I had a lot of ideas bouncing around in my head, many of which were drawn from the book",r.a.createElement("em",null,"Algorithms")," by Sanjoy Dasgupta et al. which I had been reading during my morning commute. That day I had happened to be reading the chapter on dynamic programming, and I had the Wagner\u2013Fischer algorithm for solving edit distance between two string still fresh in my mind. I figured that with some work, I could adapt that algorithm to solve for the edit distance between two documents instead. And from that, this project was born.",r.a.createElement("br",null),r.a.createElement("br",null),"If you're interested in how the original edit distance algorithm works, or the steps I took to adapt it to work with entire documents, then keep reading into the next section. If instead you want to play around with my algorithm yourself, go ahead and scroll to the bottom of the page for an interactive demo."),r.a.createElement(p.f,{variant:"h2",mt:5},"Algorithm Overview"),r.a.createElement(p.d,null),r.a.createElement(p.f,{variant:"p"},"Edit distance is defined as the minimum number of operations needed to make two strings equal, where an operation can be:",r.a.createElement("ul",null,r.a.createElement("li",null,"Inserting a new character"),r.a.createElement("li",null,"Deleting a character"),r.a.createElement("li",null,"Substituting a character for another")),"For instance, given the words ",r.a.createElement(L,null,"Saturday")," and ",r.a.createElement(L,null,"Sunday"),", the edit distance between them is 3; we must insert the letters ",r.a.createElement(L,null,"a")," and\xa0",r.a.createElement(L,null,"t")," to ",r.a.createElement(L,null,"Sunday"),", and then replace the letter\xa0",r.a.createElement(L,null,"n")," with ",r.a.createElement(L,null,"r"),". I have illustrated this in the figure below. While there exists other combinations of operations which will make these strings equal, the operations I have provided are minimal in quantity, and hence correspond to the edit distance."),r.a.createElement(g.a,{row:!0,justifyContent:"center",p:3},r.a.createElement(O,{col:{xs:1,sm:"auto"}},r.a.createElement(F,{src:I.a}))),r.a.createElement(p.f,{variant:"p"},"Solving for the edit distance between two strings lends itself well to dynamic programming, as we can break the problem down into smaller subproblems which can be reused multiple times. For instance, let's return to our example above, using the words ",r.a.createElement(L,null,"Saturday"),"\xa0and ",r.a.createElement(L,null,"Sunday"),". Let's also assume for argument's sake that we know the edit distance for the following pairs:",r.a.createElement("ol",{type:"a"},r.a.createElement("li",null,r.a.createElement(L,null,"Saturday"),", ",r.a.createElement(L,null,"Sunda")),r.a.createElement("li",null,r.a.createElement(L,null,"Saturda"),", ",r.a.createElement(L,null,"Sunday")),r.a.createElement("li",null,r.a.createElement(L,null,"Saturda"),", ",r.a.createElement(L,null,"Sunda"))),"Then from this we can deduce that the edit distance between ",r.a.createElement(L,null,"Saturday")," and\xa0",r.a.createElement(L,null,"Sunday")," must be the minimum of the following:",r.a.createElement("ul",null,r.a.createElement("li",null,"Edit distance a. + 1 to insert ",r.a.createElement(L,null,"y")," into ",r.a.createElement(L,null,"Sunda"),", or equivalently delete ",r.a.createElement(L,null,"y")," from ",r.a.createElement(L,null,"Saturday")),r.a.createElement("li",null,"Edit distance b. + 1 to insert ",r.a.createElement(L,null,"y")," into ",r.a.createElement(L,null,"Saturda"),", or equivalently delete ",r.a.createElement(L,null,"y")," from ",r.a.createElement(L,null,"Sunday")," "),r.a.createElement("li",null,"Edit distance c. + 1 if the following pair of characters (",r.a.createElement(L,null,"y, y"),") are not equal (meaning we have to substitute one), or + 0 if they are equal (which they are in this case)")),"We can generalize this into a recurrence relation as follows: given two strings denoted as ",r.a.createElement(L,null,"A, B"),", let ",r.a.createElement(L,null,"d(i,j)")," be the edit distance between the substring of the first ",r.a.createElement(L,null,"i")," characters of ",r.a.createElement(L,null,"A")," and the first ",r.a.createElement(L,null,"j")," characters of ",r.a.createElement(L,null,"B"),". Then we have:",r.a.createElement("br",null),r.a.createElement("br",null),r.a.createElement("center",null,r.a.createElement(L,null,"d(i, j) = min( d(i-1, j) + 1, d(i, j-1) + 1, d(i-1, j-1) + diff(A[i],B[j]) )")),r.a.createElement("br",null),"where ",r.a.createElement(L,null,"diff(A[i],B[j])")," is equal to 1 if the characters ",r.a.createElement(L,null,"A[i] = B[j]"),", otherwise 0. From this recurrence relationship, we can develop our dynamic programming algorithm. We can use a matrix ",r.a.createElement(L,null,"M")," to store the results of our subproblems so they can be reused without recomputing their values. Let ",r.a.createElement(L,null,"M[i,j]")," store the edit distance ",r.a.createElement(L,null,"d(i,j)"),", and let zero-indices represent the edit distance between the empty string and the corresponding substring. From this, we can infer that ",r.a.createElement(L,null,"M[0,0] = 0")," (since the empty string compared with itself has an edit distance of 0). Furthermore, any string ",r.a.createElement(L,null,"S")," compared to the empty string has an edit distance of ",r.a.createElement(L,null,"length(S)"),", so knowing this we can populate all the entries in the first row and column. Now, starting at ",r.a.createElement(L,null,"M[1,1]")," we can apply our recurrence relation defined above, since we have all needed values to compute ",r.a.createElement(L,null,"M[1,1] = diff(1,1)")," stored in the adjacent entries to the top, left, and top-left of this entry (",r.a.createElement(L,null,"M[0,1] = diff(0,1), M[1,0] = diff(1,0), M[0,0] = diff(0,0)"),"). By continuing to populate values in the matrix across the scan-line (left to right, top to bottom), the entire matrix can be populated. Finally, the bottom-right-most entry will contain the edit distance between the entirety of the strings, giving us our solution.",r.a.createElement("br",null),r.a.createElement("br",null),"From this matrix, we can also determine the optimal sequence of operations needed to make the two strings equal by walking backwards from the bottom-right-most square to ",r.a.createElement(L,null,"M[1,1]"),". At each step in the walk, we move up, left, or diagonally up and left into the square with the least cost. In the case of a tie, we always opt for moving on a diagonal, so we will reach ",r.a.createElement(L,null,"M[1,1]")," with fewer steps. I have illustrated this process below, with arrows marking the path walked, grey squares (",r.a.createElement(p.f,{variant:"p",color:"#D8D8D8"},r.a.createElement("i",{className:"fas fa-square",color:"#D8D8D8"})),") representing the case where characters are the same (cost of 0), green squares (",r.a.createElement(p.f,{variant:"p",color:"#A8F7A6"},r.a.createElement("i",{className:"fas fa-square",color:"#A8F7A6"})),") representing insertions (cost of 1), and purple squares (",r.a.createElement(p.f,{variant:"p",color:"#A088FF"},r.a.createElement("i",{className:"fas fa-square",color:"#A088FF"})),") representing substitutions (cost of 1)."),r.a.createElement(g.a,{row:!0,justifyContent:"center",p:3},r.a.createElement(O,{col:{xs:1,sm:"auto"}},r.a.createElement(F,{src:T.a}))),r.a.createElement(p.f,{variant:"p"},"Initially I thought I could apply this algorithm directly to two documents, treating each line as if it were a character. But this did not produce the results I was expecting. While this approach did manage to match up identical lines with each other, it would pair inserted, modified or deleted lines with random lines in the other file. This is because it was treating each line like a character, and when comparing two characters, they either are the same or they are not. However when dealing with entire lines of text, this is not entirely true: there is also a concept of ",r.a.createElement("em",null,"similarity")," between lines, and to match lines with there most similar pair, I somehow had to quantify this.",r.a.createElement("br",null),r.a.createElement("br",null),"Luckily for me I had a great tool to do so, having just implemented the edit distance algorithm. So for my second approach, I would modify my algorithm to compute the edit distance over the entire document where the cost of an insertion or deletion is equal to the length of the inserted or deleted line, and the cost of a substitution is the edit distance between the lines being substituted! This algorithm yielded much better results, however it still wasn't perfect. Consider the following example documents:"),r.a.createElement(g.a,{row:!0,justifyContent:"center",p:3},r.a.createElement(O,{col:3/7,p:{xs:1,md:3},mx:{xs:1,md:3}},r.a.createElement(L,null,"Hello World!",r.a.createElement("br",null),"Hello")),r.a.createElement(O,{col:3/7,p:{xs:1,md:3},mx:{xs:1,md:3}},r.a.createElement(L,null,"Hello"))),r.a.createElement(p.f,{variant:"p"},"My algorithm would opt to align ",r.a.createElement(L,null,'"Hello World!"')," with ",r.a.createElement(L,null,'"Hello"')," and then consider the ",r.a.createElement(L,null,'"Hello"')," in the left-most document as an insertion (at a cost of 7 for substitution + 5 for insertion = 12), since the substitution operation is a diagonal step on the walk described above. However the desired behaviour would have been to consider ",r.a.createElement(L,null,'"Hello World!"')," as an insertion, and then match ",r.a.createElement(L,null,'"Hello"')," with ",r.a.createElement(L,null,'"Hello"')," (also at cost of 12), but this does not result in a diagonal step. To overcome this, I initially tried removing the prioritization on diagonal steps in the case of a tie, but this ended up producing strange behaviour. I also tried re-weighting the cost of the operations, making insertions and deletions cheaper, but when doing so I could always provide an adversarial example which would once again produce strange behaviour.",r.a.createElement("br",null),r.a.createElement("br",null),'I was finally able to overcome this when I had the realization that the algorithms core goal should be to match up as many identical lines as possible, and then find the best pairing of similar lines afterwards. With this in mind, I restructured the algorithm so that whenever it paired two identical lines together, this operation would have a negative cost such that the resulting element in the matrix becomes 0. Furthermore, I increased the cost of all other operations by 1, thus reserving the 0-cost element for perfect matches. By doing so the algorithm will always opt to pair up macthing lines (as they have a cost strictly less than all other operations), whilst matching up the non-matching lines with their most similar pairs. Unfortunately while this change does pair up the lines of the two documents in the optimal fashion, it comes at the cost of losing the measurement of total "edit distance" between the documents (which luckily is of no interest to me).',r.a.createElement("br",null),r.a.createElement("br",null),"And with that, we have my algorithm for document comparison. To test this algorithm out, see the next interactive section below where you can see how this algorithm performs with your own documents!"),r.a.createElement(p.f,{variant:"h2",mt:5},"Try it Out!"),r.a.createElement(p.d,null))}}]),t}(a.Component),q=n(46),W=Object.freeze({INSERT:1,DELETE:2,REPLACE:3,NONE:4});function H(e,t){for(var n=new Array(t),a=0;a<t;a++)n[a]=new Array(e);return n}function M(e,t,n){return n<0||n>=e.length?Number.POSITIVE_INFINITY:t<0||t>=e[0].length?Number.POSITIVE_INFINITY:e[n][t]}var B=function e(t,n){var a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;Object(c.a)(this,e),this.operation=t,this.symbol=n,this.secondarySymbol=a},P=function(){function e(t,n){var a=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];Object(c.a)(this,e),this.newWord=t,this.oldWord=n;var r=a?function(e,t){var n=e.length+1,a=t.length+1,r=H(n,a);r[0][0]=0;for(var i=1;i<n;i++)r[0][i]=r[0][i-1]+e[i-1].length+1;for(var o=1;o<a;o++)r[o][0]=r[o-1][0]+t[o-1].length+1;for(var l=1;l<n;l++)for(var c=1;c<a;c++){var s=0;s=e[l-1]!==t[c-1]?new P(e[l-1],t[c-1],!1).minEditDistance:-r[c-1][l-1]-1,r[c][l]=Math.min(r[c-1][l]+t[c-1].length,r[c][l-1]+e[l-1].length,r[c-1][l-1]+s)+1}return r}(t,n):function(e,t){var n=e.length+1,a=t.length+1,r=H(n,a);r[0][0]=0;for(var i=1;i<n;i++)r[0][i]=r[0][i-1]+1;for(var o=1;o<a;o++)r[o][0]=r[o-1][0]+1;for(var l=1;l<n;l++)for(var c=1;c<a;c++){var s=0;e[l-1]!==t[c-1]&&(s=1),r[c][l]=Math.min(r[c-1][l],r[c][l-1],r[c-1][l-1])+s}return r}(t,n);this.minEditDistance=r[n.length][t.length],this.fullEdits=function(e,t,n){for(var a=[],r=t.length,i=n.length;0!==i||0!==r;)if(0!==M(e,r,i)){var o=M(e,r-1,i),l=M(e,r,i-1),c=M(e,r-1,i-1),s=Math.min(o,l,c);if(s===c){var u=M(e,r,i);r--,i--,c<u?a.push(new B(W.REPLACE,t[r],n[i])):a.push(new B(W.NONE,t[r]))}else s===o?(r--,a.push(new B(W.INSERT,t[r]))):(i--,a.push(new B(W.DELETE,n[i])))}else r--,i--,a.push(new B(W.NONE,t[r]));return a.reverse()}(r,t,n),this.edits=this.fullEdits.filter((function(e){return e.operation!==W.NONE}))}return Object(s.a)(e,[{key:"getNumDisjointReplacements",value:function(){if(0===this.fullEdits.length)return 0;for(var e=0,t=null,n=0;n<this.fullEdits.length;n++){var a=this.fullEdits[n].operation;a===W.REPLACE&&t!==W.REPLACE&&e++,t=a}return e}}]),e}();function z(e){return e.length>0?e[e.length-1].entityNumber:Number.NEGATIVE_INFINITY}function _(e,t){var n=z(e[W.DELETE]),a=z(e[W.INSERT]),r=z(e[W.NONE]),i=Math.max(n,a,r);return n===t-1?e[W.DELETE].pop():a===t-1?e[W.INSERT].pop():i===n?e[W.DELETE].pop():i===a?e[W.INSERT].pop():e[W.NONE].pop()}function J(e){var t=[],n=1;return e.fullEdits.forEach((function(e){t.push.apply(t,Object(q.a)(function(e,t){var n=e.operation,a=e.symbol,r=e.secondarySymbol;if(n===W.REPLACE){var i=new P(a,r,!1),o=i.fullEdits.map((function(e){return e.operation===W.REPLACE?new B(W.INSERT,e.symbol):e})).filter((function(e){return e.operation!==W.DELETE})),l=i.fullEdits.map((function(e){return e.operation===W.REPLACE?new B(W.DELETE,e.secondarySymbol):e})).filter((function(e){return e.operation!==W.INSERT}));return[new Y(W.INSERT,a,t,o),new Y(W.DELETE,r,t,l)]}return W.INSERT,[new Y(n,a,t)]}(e,n))),n++})),t}function V(e){var t=[],n=[];return e.forEach((function(e){var a=e.operation,r=e.subEditEntities;a===W.INSERT?(t.push(e),null===r&&n.push(new Y(W.NONE,"","*"))):a===W.DELETE?(n.push(e),null===r&&t.push(new Y(W.NONE,"","*"))):(t.push(e),n.push(e))})),[t,n]}var Y=function e(t,n,a){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;Object(c.a)(this,e),this.operation=t,this.symbol=n,this.entityNumber=a,this.subEditEntities=r},G=n(37);function U(){var e=Object(f.a)(["\n    display: inline-block;\n    ",";\n"]);return U=function(){return e},e}function $(){var e=Object(f.a)(["\n    width: 32px;\n    min-width: 32px;\n    padding-right: 8px;\n    padding-left: 0px;\n    text-align: right;\n    color: #AAA;\n    background-color: rgba(0, 0, 0, .1);\n"]);return $=function(){return e},e}function K(){var e=Object(f.a)(["\n    display: inline-block;\n    padding: 2px 8px;\n    white-space: pre;\n"]);return K=function(){return e},e}function Q(){var e=Object(f.a)(["\n    width: 100%;\n    height: auto;\n    display: inline-flex;\n    overflow: scroll;\n    text-align: left;\n    font-family: 'Inconsolata', monospace;\n    font-size: 16px;\n\n    ",";\n"]);return Q=function(){return e},e}var X=l.e.div(Q(),(function(e){return e.operation===W.INSERT?"background-color: #daffd9":e.operation===W.DELETE?"background-color: #ffd9df":void 0})),Z=l.e.div(K()),ee=Object(l.e)(Z)($()),te=l.e.div(U(),(function(e){return e.operation===W.INSERT?"background-color: #a8f7a6":e.operation===W.DELETE?"background-color: #f7a6a6":void 0})),ne=function(e){function t(){return Object(c.a)(this,t),Object(u.a)(this,Object(h.a)(t).apply(this,arguments))}return Object(d.a)(t,e),Object(s.a)(t,[{key:"render",value:function(){var e=this.props.editEntity,t=e.operation,n=e.symbol,a=e.entityNumber,i=e.subEditEntities,o=r.a.createElement("div",null,"\xa0");t===W.INSERT?o="+":t===W.DELETE&&(o="-");var l=r.a.createElement(Z,{operation:t},n);return i&&(l=r.a.createElement(Z,{operation:t},i.map((function(e,t){return r.a.createElement(te,{operation:e.operation,key:t},e.symbol)})))),r.a.createElement(X,{operation:t},r.a.createElement(ee,{operation:t},a),r.a.createElement(Z,{operation:t},o),l)}}]),t}(a.Component);function ae(){var e=Object(f.a)(["\n    display: inline-block;\n    border: 2px solid ",";\n    color: ",";\n    border-radius: 16px;\n    padding: 4px 8px;\n    margin-left: 16px;\n    font-size: 12px;\n"]);return ae=function(){return e},e}function re(){var e=Object(f.a)(["\n    margin-left: 16px;\n"]);return re=function(){return e},e}var ie=g.d.label(re()),oe=g.d.div(ae(),(function(e){return e.color}),(function(e){return e.color}));var le=function(e){var t,n=Object(G.a)({state:"viewInline"}),a=J(e.editDistance),i=r.a.createElement(O,{row:!0,m:2,mb:5},function(e){for(var t=e.reduce((function(e,t){return e[t.operation].push(t),e}),{1:[],2:[],3:[],4:[]}),n=[],a=e.length+1,r=0;r<e.length;r++){var i=_(t,a);n.push(i),a=i.entityNumber}return n.reverse()}(J(e.editDistance)).map((function(e,t){return r.a.createElement(ne,{editEntity:e,key:t})}))),o=r.a.createElement(O,{row:!0,m:2,mb:5},r.a.createElement(g.a,{col:.5},V(a)[0].map((function(e,t){return r.a.createElement(ne,{editEntity:e,key:t})}))),r.a.createElement(g.a,{col:.5},V(a)[1].map((function(e,t){return r.a.createElement(ne,{editEntity:e,key:t})})))),l=[i];return"viewSide"===n.state&&(l=[o]),r.a.createElement(r.a.Fragment,null,r.a.createElement(g.a,{row:!0,mt:2},r.a.createElement(g.a,{col:!0},r.a.createElement(ie,{mx:1},r.a.createElement(p.e,{checked:e.delayedComputation,onChange:e.toggleDelayedComputation,scale:"sm",name:"xs",verticalAlign:"middle"})," Delayed Computation"),r.a.createElement(oe,{color:(t=e.diffStateString,"Done"===t?"#3bd12e":"Waiting"===t?"#17A2B8":"Processing"===t?"#AF1213":"#333")},r.a.createElement("strong",null,e.diffStateString)),r.a.createElement(p.d,null),r.a.createElement(p.c,Object.assign({},n,{"aria-label":"display options",py:1}),r.a.createElement(g.a,{row:!0,justifyContent:{md:"left"}},r.a.createElement(g.a,{col:{xs:1,md:"auto"}},r.a.createElement(ie,null,r.a.createElement(p.b,Object.assign({},n,{value:"viewInline"}))," Inline")),r.a.createElement(g.a,{col:{xs:1,md:"auto"},mt:{xs:2,md:0}},r.a.createElement(ie,null,r.a.createElement(p.b,Object.assign({},n,{value:"viewSide"}))," Side")))))),l.map((function(e){return e})))},ce=["Hello World!","Have fun playing around with my implementation of a text comparison tool,","based off of the Wagner\u2013Fischer dynamic programming algorithm for calculating","the Levenshtein distance between two strings.","I have tried to display differences in an easy-to-read format, by grouping","contiguous operations together, and by highlighting small differences between","similar lines (as seen above).","New lines appear like this","(with no per-character highlighting)","(again, with no per-character highlighting)","Finally, if you're working with large documents, consider keeping",'"Delayed Computation" on, as it will wait until you stop typing before',"recomputing the differences, instead of after each keystroke."],se=["Hello World!","Have fun playing around with my implementation of a text diff tool,","based off of the Wagner\u2013Fischer DP algorithm for calculating","the edit distance between two strings.","I have tried to display differences in an easy-to-read format, by grouping","contiguous operations together, and by highlighting small differences between","similar lines (as seen above).","(with no per-character highlighting)","And deleted lines appear like this","(again, with no per-character highlighting)","Finally, if you're working with large documents, consider keeping",'"Delayed Computation" on, as it will wait until you stop typing before',"recomputing the differences, instead of after each keystroke."],ue=function(e){function t(){var e;return Object(c.a)(this,t),(e=Object(u.a)(this,Object(h.a)(t).call(this))).state={newDocument:ce,oldDocument:se,editDistance:new P(ce,se),delayedComputation:!0,diffStateString:"Done"},e.computeDiffTimer=null,e.processingTimer=null,e.toggleDelayedComputation=e.toggleDelayedComputation.bind(Object(m.a)(e)),e.triggerDiffComputation=e.triggerDiffComputation.bind(Object(m.a)(e)),e.recomputeDiff=e.recomputeDiff.bind(Object(m.a)(e)),e.updateDocument=e.updateDocument.bind(Object(m.a)(e)),e.updateDiffStateString=e.updateDiffStateString.bind(Object(m.a)(e)),e}return Object(d.a)(t,e),Object(s.a)(t,[{key:"triggerDiffComputation",value:function(){var e=this;clearTimeout(this.computeDiffTimer),this.state.delayedComputation?(this.updateDiffStateString("Waiting"),this.computeDiffTimer=setTimeout((function(){e.recomputeDiff()}),1e3)):this.recomputeDiff()}},{key:"recomputeDiff",value:function(){var e=this;this.updateDiffStateString("Processing"),clearTimeout(this.processingTimer),this.processingTimer=setTimeout((function(){var t=e.state,n=t.newDocument,a=t.oldDocument,r=new P(n,a);e.setState({editDistance:r}),e.updateDiffStateString("Done")}),100)}},{key:"updateDocument",value:function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=this.state,a=n.newDocument,r=n.oldDocument;this.setState({newDocument:t?e.value.split("\n"):a,oldDocument:t?r:e.value.split("\n")}),this.triggerDiffComputation()}},{key:"toggleDelayedComputation",value:function(){this.setState({delayedComputation:!this.state.delayedComputation})}},{key:"updateDiffStateString",value:function(e){this.setState({diffStateString:e})}},{key:"render",value:function(){return r.a.createElement(r.a.Fragment,null,r.a.createElement(p.a,null),r.a.createElement(r.a.Fragment,null,r.a.createElement(v,null),r.a.createElement(g.a,{width:1,height:100,px:{xs:3,md:6},py:3},r.a.createElement(R,null),r.a.createElement(k,{newDocument:ce.join("\n"),oldDocument:se.join("\n"),updateDocument:this.updateDocument}),r.a.createElement(le,{editDistance:this.state.editDistance,delayedComputation:this.state.delayedComputation,toggleDelayedComputation:this.toggleDelayedComputation,diffStateString:this.state.diffStateString}))))}}]),t}(a.Component);Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));o.a.render(r.a.createElement(l.b,{theme:{colors:{text:"#000",background:"#fff",primary:"#17A2B8",modes:{dark:{text:"#fff",background:"#000",primary:"#0cf"}}}}},r.a.createElement(ue,null)),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(e){e.unregister()}))}},[[52,1,2]]]);
//# sourceMappingURL=main.32077dc1.chunk.js.map